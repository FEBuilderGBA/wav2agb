#include <sndfile.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <string.h>
#include <libgen.h>
#include <assert.h>
#include <time.h>

#include "utils.h"
#include "converter.h"

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

static int __block_pos;
static FILE *__out_file;
static void bin_write_init(FILE *file) {
    __block_pos = 0;
    __out_file = file;
}

static void bin_write(uint8_t data) {
    if (__block_pos++ == 0) {
        fprintf(__out_file, "\r\n    .byte   0x%02X", data);
    } else {
        fprintf(__out_file, ", 0x%02X", data);
    }
    __block_pos %= 16;
}

static float hp_alpha = 0.0f;

static int get_sample(SNDFILE *file, int loop_start, int loop_end, bool loop_enabled) {
    static float loop_sample = 0.0f;
    float data;
    sf_count_t pos = sf_seek(file, 0, SEEK_CUR);

    if (!sf_read_float(file, &data, 1)) {
        die("Read overlength");
    }

    if (loop_enabled && pos == loop_start) {
        loop_sample = data;
    } else if (loop_enabled && pos == loop_end) {
        data = loop_sample;
    }

    float noise = (float)rand() * (1.0f / (float)RAND_MAX);

    // apply hp to white noise
    float hp_in = noise;
    static float hp_state = 0.0f;
    hp_state += hp_alpha * (hp_in - hp_state);
    float hp_out = hp_in + hp_state;


    // normalize data to char range
    data *= 128.0f,
    // apply dither
    data += hp_out;
    data = floorf(data);
    int retval = (int)data;
    if (retval < -128)
        retval = -128;
    else if (retval > 127)
        retval = 127;

    return retval;
}

static const int8_t lookup_table[] = { 
    0, 1, 4, 9, 16, 25, 36, 49, -64, -49, -36, -25, -16, -9, -4, -1 
};

static uint8_t get_nearest_lut_index(int *prev_level, int current_level) {
    int lowest_diff = 256;
    uint8_t lowest_diff_index = 0;

    for (uint8_t i = 0; i < 16; i++) {
        if (abs(*prev_level + lookup_table[i] - current_level) < lowest_diff &&
                (*prev_level + lookup_table[i] >= -128) &&
                (*prev_level + lookup_table[i]) < 128) {
            lowest_diff = abs(*prev_level + lookup_table[i] - current_level);
            lowest_diff_index = i;
        }
    }
    *prev_level += lookup_table[lowest_diff_index];
    assert(*prev_level >= -128);
    assert(*prev_level < 128);
    assert(lowest_diff_index < 16);
    return lowest_diff_index;
}

void convert(const char wav_file[], const char s_file[], bool compress) {
    // get random seed for dither generator
    time_t t;
    srand((unsigned int)time(&t));

    SF_INFO in_info = {
        .format = 0,
    };

    SNDFILE *in_file = sf_open(wav_file, SFM_READ, &in_info);

    if (in_file == NULL)
        snddie(NULL);

    int samplerate = in_info.samplerate;
    int channels = in_info.channels;

    if (channels != 1) {
        fprintf(stderr, "Only mono WAVs are supported. Supplied file has %d channels\n", channels);
        exit(EXIT_FAILURE);
    }

    // calc dither frequency rc
    float rc = 1.0f / (3000.0f * 2.0f * (float)M_PI);
    float dt = 1.0f / (float)samplerate;
    hp_alpha = dt / (rc + dt);

    // get file length in samples

    sf_count_t length = sf_seek(in_file, 0, SEEK_END);
    sf_count_t loop_start = 0;
    sf_count_t loop_end = length;
    if (length == -1)
        snddie(in_file);

    sf_seek(in_file, 0, SEEK_SET);

    char basenote = 60;
    char detune = 0;
    bool loop = false;
    SF_INSTRUMENT in_instr;
    if (sf_command(in_file, SFC_GET_INSTRUMENT, &in_instr, sizeof(in_instr)) == SF_TRUE) {
        if (in_instr.loops[0].mode != SF_LOOP_NONE) {
            if (in_instr.loops[0].start == 0 && in_instr.loops[0].end == 0)
                goto escape_loop;
            if (in_instr.loops[0].start >= in_instr.loops[0].end)
                goto escape_loop;
            loop = true;
            loop_start = in_instr.loops[0].start;
            loop_end = in_instr.loops[0].end;
            length = loop_end + 1;
        }
escape_loop:
        basenote = in_instr.basenote;
        detune = in_instr.detune;
        //printf("read detune value of %d\n", (int)detune);
    }

    FILE *out_file = fopen(s_file, "w");
    if (!out_file)
        pdie("fopen");

    char symbol_name[strlen(wav_file) + 1];
    strcpy(symbol_name, wav_file);
    char *symbol = basename(symbol_name);
    strip_extension(symbol, "wav");

    fprintf(out_file, "@ File generated by wav2agb ~ ipatix\r\n\r\n");
    fprintf(out_file, "    .section .rodata\r\n");
    fprintf(out_file, "    .global %s\r\n", symbol);
    fprintf(out_file, "    .align  2\r\n\r\n%s:\r\n\r\n", symbol);

    fprintf(out_file, "    .byte   0x%X, 0x0, 0x0, 0x%X\r\n", compress ? 1 : 0, loop ? 0x40 : 0x0);
    float pitch;
    if (basenote == 60 && detune == 0) {
        pitch = (float)samplerate;
    } else {
        pitch = (float)samplerate * powf(2, (float)(60 - basenote) / 12.f + (float)detune / 1200.f);
    }
    fprintf(out_file, "    .word   0x%08X  @ Mid-C ~ %f\r\n", (uint32_t)(pitch * 1024.f), pitch);
    fprintf(out_file, "    .word   %d, %d\r\n", (int)loop_start, (int)loop_end);

    int level = 0, approx_level = 0;

    bin_write_init(out_file);

    if (compress) {
        for (sf_count_t i = 0; i < length;) {
            //printf("Processing block starting at %d\n", (int)i);
            uint8_t msb = 0;
            uint8_t lsb = 0;

            // encode first base sample
            approx_level = get_sample(in_file, (int)loop_start, (int)loop_end, loop);
            level = approx_level;

            bin_write((uint8_t)level);

            if (++i >= length)
                break;

            // encode first diff sample
            level = get_sample(in_file, (int)loop_start, (int)loop_end, loop);
            lsb = get_nearest_lut_index(&approx_level, level);
            bin_write(lsb);

            if (++i >= length)
                break;

            int block_align = 0x3E;

            do {
                level = get_sample(in_file, (int)loop_start, (int)loop_end, loop);
                msb = get_nearest_lut_index(&approx_level, level);

                if (++i >= length) {
                    level = 0;
                    uint8_t lsb2 = get_nearest_lut_index(&approx_level, level);
                    bin_write((uint8_t)(lsb2 | (msb << 4)));
                    break;
                }

                level = get_sample(in_file, (int)loop_start, (int)loop_end, loop);
                lsb = get_nearest_lut_index(&approx_level, level);
                bin_write((uint8_t)(lsb | (msb << 4)));
                if (++i >= length)
                    break;
            } while ((block_align -= 2) > 0);
        }
    } else {
        for (sf_count_t i = 0; i < length; i++) {
            bin_write((uint8_t)get_sample(in_file, (int)loop_start, (int)loop_end, loop));
        }
    }
    fprintf(out_file, "\r\n\r\n    .end\r\n");
    int err = sf_close(in_file);
    if (err != 0)
        die(sf_error_number(err));
    if (fclose(out_file))
        pdie("fclose");
}
