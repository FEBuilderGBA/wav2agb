#include <sndfile.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <string.h>
#include <libgen.h>

#include "utils.h"
#include "converter.h"

static int __block_pos;
static FILE *__out_file;
static void bin_write_init(FILE *file) {
    __block_pos = 0;
    __out_file = file;
}

static void bin_write(uint8_t data) {
    if (__block_pos++ == 0) {
        fprintf(__out_file, "\r\n    .byte   0x%02X", data);
    } else {
        fprintf(__out_file, ", 0x%02X", data);
    }
    __block_pos %= 16;
}

static int get_sample(SNDFILE *file, int loop_pos, bool loop_enabled) {
    static short loop_sample = 0;
    short data;
    bool save_loop = false;
    if (loop_enabled && sf_seek(file, 0, SEEK_CUR) == loop_pos)
        save_loop = true;
    if (!sf_read_short(file, &data, 1)) {
        if (loop_enabled)
            data = loop_sample;
        data = 0;
    } else {
        if (save_loop)
            loop_sample = data;
    }
    return data / 256;
}

static const int8_t lookup_table[] = { 
    0, 1, 4, 9, 16, 25, 36, 49, -64, -49, -36, -25, -16, -9, -4, -1 
};

static uint8_t get_nearest_lut_index(int *approx_level, int current_level) {
    int lowest_diff = 256;
    uint8_t lowest_diff_index = 0;

    for (uint8_t i = 0; i < 16; i++) {
        if (abs(*approx_level + lookup_table[i] - current_level) < lowest_diff &&
                (*approx_level + lookup_table[i] >= -128) &&
                (*approx_level + lookup_table[i]) < 128) {
            lowest_diff = abs(*approx_level + lookup_table[i] - current_level);
            lowest_diff_index = i;
        }
    }
    *approx_level += lookup_table[lowest_diff_index];
    return lowest_diff_index;
}

void convert(const char wav_file[], const char s_file[], bool compress) {
    SF_INFO in_info = {
        .format = 0,
    };

    SNDFILE *in_file = sf_open(wav_file, SFM_READ, &in_info);

    if (in_file == NULL)
        snddie(NULL);

    int samplerate = in_info.samplerate;
    int channels = in_info.channels;

    if (channels != 1) {
        fprintf(stderr, "Only mono WAVs are supported. Supplied file has %d channels\n", channels);
        exit(EXIT_FAILURE);
    }

    // get file length in samples

    sf_count_t length = sf_seek(in_file, 0, SEEK_END);
    sf_count_t loop_start = 0;
    if (length == -1)
        snddie(in_file);

    sf_seek(in_file, 0, SEEK_SET);

    char basenote = 60;
    char detune = 0;
    bool loop = false;
    SF_INSTRUMENT in_instr;
    if (sf_command(in_file, SFC_GET_INSTRUMENT, &in_instr, sizeof(in_instr)) == SF_TRUE) {
        if (in_instr.loops[0].mode != SF_LOOP_NONE) {
            loop = true;
            loop_start = in_instr.loops[0].start;
            length = in_instr.loops[0].end;
        }
        basenote = in_instr.basenote;
        detune = in_instr.detune;
    }

    FILE *out_file = fopen(s_file, "w");
    if (!out_file)
        pdie("fopen");

    char symbol_name[strlen(wav_file) + 1];
    strcpy(symbol_name, wav_file);
    char *symbol = basename(symbol_name);
    strip_extension(symbol, "wav");

    fprintf(out_file, "@ File generated by wav2agb ~ ipatix\r\n\r\n");
    fprintf(out_file, "    .section .rodata\r\n");
    fprintf(out_file, "    .global %s\r\n", symbol);
    fprintf(out_file, "    .align  2\r\n\r\n%s:\r\n\r\n", symbol);

    fprintf(out_file, "    .byte   0x%X, 0x0, 0x0, 0x%X\r\n", compress ? 1 : 0, loop ? 0x40 : 0x0);
    uint32_t pitch;
    float pitchf;
    if (basenote == 60 && detune == 0) {
        pitchf = (float)(pitch = ((uint32_t)samplerate * 1024));
    } else {
        printf("hello\n");
        pitch = (uint32_t)(pitchf = (float)samplerate * 1024.f * powf(2, (float)(60 - basenote) / 12.f + (float)detune / 1200.f));
    }
    fprintf(out_file, "    .word   0x%08X  @ Mid-C ~ %f\r\n", pitch, pitchf);
    fprintf(out_file, "    .word   %d, %d\r\n", (int)loop_start, (int)length);

    int level = 0, approx_level = 0;

    bin_write_init(out_file);

    if (compress) {
        for (sf_count_t i = 0; i < length;) {
            uint8_t msb = 0;
            uint8_t lsb = 0;

            // encode first base sample
            approx_level = get_sample(in_file, (int)loop_start, loop);
            level = approx_level;

            bin_write((uint8_t)level);

            if (++i > length)
                break;

            // encode first diff sample
            level = get_sample(in_file, (int)loop_start, loop);
            lsb = get_nearest_lut_index(&approx_level, level);
            bin_write(lsb);

            if (++i > length)
                break;

            int block_align = 0x3E;

            do {
                level = get_sample(in_file, (int)loop_start, loop);
                msb = get_nearest_lut_index(&approx_level, level);

                if (++i > length) {
                    level = 0;
                    uint8_t lsb2 = get_nearest_lut_index(&approx_level, level);
                    bin_write((uint8_t)(lsb2 | (msb << 4)));
                    break;
                }

                level = get_sample(in_file, (int)loop_start, loop);
                lsb = get_nearest_lut_index(&approx_level, level);
                bin_write((uint8_t)(lsb | (msb << 4)));
                if (++i > length)
                    break;
            } while (block_align -= 2 > 0);
        }
    } else {
        for (sf_count_t i = 0; i < length; i++) {
            bin_write((uint8_t)get_sample(in_file, (int)loop_start, loop));
        }
    }
    fprintf(out_file, "\r\n\r\n    .end\r\n");
    int err = sf_close(in_file);
    if (err != 0)
        die(sf_error_number(err));
    if (fclose(out_file))
        pdie("fclose");
}
